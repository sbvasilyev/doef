#+title: ДОЭФ. Python
#+author: Sergey Vasilyev
#+date: 2024-11-13
#+filetags: :courses:hse:doef:

* Введение в python
** Переменные, базовые типы и операции над ними

Python - язык с динамической типизацией, то есть о том, что мы передали строку в функцию, принимающую на вход целое число, узнаем только в момент исполнения кода. Справделивости ради, начиная с версии 3.5, были добавлены type hints, которые при попытки передать в функцию не то позволят редактору показать предупреждение. Но если предупреждение не было замечено по той или иной причине, то ошибка возникет только при непосредственном исполнении кода (что может быть часу на пятом-шестом его работы, к слову).

#+begin_src python :tangle "python/intro.py"
  x = 30
  x = True
  
  y = 0.5
  s = "Hello, Мир!"
#+end_src

Как видно из примера выше, переменные объявляются с помощью синтаксиса ~var_name = value~, а тип переменной определяется значением. Обратим внимание, что в переменную можно "перезаписать" значение другого типа. Примечание со звездочкой: связано это с тем, что в python даже в случае примитивных типов переменная является указателем на объект, а поэтому ничего не "перезаписывается" в память, выделенную для значения предыдущего типа, а просто переменная начинает указывать на другое место в памяти, которое было выделено под значение нового типа. Как упражение, подумайте, что будет выведено в результате исполнения следующего кода.
#+begin_src python
  a = 30
  b = a

  b = 42
  print(a) # => 42 или 30?
#+end_src

Также, можем убедиться, что примитивные типы (навроде целых чисел или логического типа) обернуты в объект:
#+begin_src python :tangle "python/intro.py"
  print(f"type of 1 is {type(1)}")       # => <class 'int'>
  print(f"type of True is {type(True)}") # => <class 'bool'>
#+end_src

Далее, рассмотрим доступные нам примитивные типы и операции над ними.

*** Числовые типы

В python нам доступны числовые типы для целых чисел (~int~) и чисел с плавающей точкой (~float~).
#+begin_src python :tangle "python/intro.py"
  x = 42
  print(f'type of x is: {type(x)}') # => int

  y = 42.0
  print(f'type of y is: {type(y)}') # => float
#+end_src

Используем термин "число с плавающей точкой" вместо действительного числа намеренно, так как арифметика может давать неожиданные результаты в силу того, что числа с плавающей точкой хранятся в памяти компьютера с ограниченной точностью:
#+begin_src python :tangle "python/intro.py"
  1.0 + 1.0 + 1.0 == 3.0 # => False
#+end_src

Доступны все операции над числовыми типами, которые мы можем ожидать, включая возвдение в степень и взятие по модулю:
#+begin_src python :tangle "python/intro.py"
  x = 11
  print(x + 31)   # => 42
  print(x - 12)   # => -1
  print(x * 3)    # => 33
  print(x / 2)    # => 5.5
  print(x // 2)   # => 5     (целочисленное деление)
  print(x ** 2)   # => 121   (возведение в степень)
  print(x % 3)    # => 2     (остаток от деления)
#+end_src

Обратим внимание, что если один из операндов ~float~, то операнд типа ~int~ будет автоматически приведен к типу ~float~:
#+begin_src python :tangle "python/intro.py"
  print(x + 2.0)  # => 13.0
  print(x ** 2.0) # => 121.0
#+end_src

*** Сокращенные операторы

В python в отличие от большинства С-подобных языков отсутствует оператор инкремента. Присутствуют сокращенные операторы ~+=~, ~-=~, ~*=~ и ~/=~:
#+begin_src python :tangle "python/intro.py"
  i = 1
  while i <= 10:
      print(f'square of {i} is {i ** 2}')
      i += 1
#+end_src

Сокращенный оператор (на примере ~lhs += rhs~) это сокращенный аналог (но не просто краткая запись) выражения ~lhs = lhs + rhs~. Выражение слева (~lhs~) может состоять не только из имени переменной, и в случае сокращенного оператора оно вычисляется только один раз, что важно, например, если это вычисление дорогое, например, выражение слева это получение элемента списка по индексу, расчтанному с помощью дорогой функции. Также не стоит забывать о возможных ошибках при вычислении ~lhs~ дважды, если присутсвует стохастика. Ниже пример, показывающий различия:
#+begin_src python :tangle "python/intro.py"
  def id_with_print(x):
      print(f"function called with x = {x}")
      return x

  some_list = [0, 1, 2, 3, 4, 5]

  # with +=
  some_list[id_with_print(2)] += 4
  # => "function called with x = 2" печатается один раз

  # without +=
  some_list[id_with_print(2)] = some_list[id_with_print(2)] + 4
  # => "function called with x = 2" печатается дважды
#+end_src

*** Логический тип

В python присутствует логический тип ~bool~, который может принимать два значения: истина (~True~) и ложь (~False~). Обратим внимание на первые заглавные буквы, ни ~true/false~, ни ~TRUE/FALSE~ не являются валидными идентификаторами.

Операторы также вполне ожидаемые:
#+begin_src python :tangle "python/intro.py"
  t = 42 > -90  # => True
  f = 0 != 0    # => False

  print(f"True AND False is {t and f}")  # => False
  print(f"True OR  False is {t or f}")   # => True
  print(f"     NOT False is {not f}")    # => True
#+end_src

Полезным свойством операторов ~and~ и ~or~ является вычисление по короткой схеме (не уверен, что такой перевод устоявшийся. В английском это звучит как short-circuit evaluation, либо иногда McCarthy evaluation в честь ключевого создателя семейства языков Lisp, где такие операторы, судя по всему, и появились впервые). Это значит, что для ~and~ второй операнд будет вычислен, только если первый истинен (а для ~or~, наоборот, если ложный). Пример:
#+begin_src python :tangle "python/intro.py"
  x = 0
  y = 5
  if x != 0 and y / x > 1:
      print(f"y is {y}")
#+end_src

Если в коде выше заменим ~and~ на побитовое И (оператор ~&~), которое не обладает вышеуказанным свойством (то есть вычисляет оба операнда всегда), то аналогичный код будет падать с ошибкой ~ZeroDivisionError~:
#+begin_src python
  if x != 0 & y / x > 1:
      print(f"y is {y}")

  # => ZeroDivisionError: division by zero
#+end_src

*** Выражение присвоения (*)

В самом начале мы вспомнили/узнали, как выглядит оператор присвоения и то, что называть присвоением происходящее не совсем точно. В духе C мы можем присвоить значение (далее как и ранее имеем в виду, что это будут указатели на один и тот же объект) сразу нескольким переменным:
#+begin_src python
x = y = z = 5
#+end_src

Все также в духе C можем предположить, что оператор присвоения ассоциативен справа и при выполении возвращает присвоенное значение, то есть имеем последовательность ~(x = (y = (z = 5)) => (x = (y = 5)) => (x = 5) => 5~ и последнее значение просто не используется. Убедиться, что наша догадка неверна просто (код ниже не выполнится из-за ошибки ~SyntaxError: invalid syntax~):
#+begin_src python
  if (x = 5):
      print(x)
#+end_src

Но, начиная с версии 3.8 доступно выражение присвоения (assignment expression) ~:=~, которое ведет себя почти так как мы ожидаем:
#+begin_src python
  if (x := 5):
      print(x)    # => 5
#+end_src

Однако выше написано почти из-за отсутсвия ассоциативности справа. Чтобы первый пример с множественным присваиванием заработал нужны скобки, иначе ~SyntaxError~:
#+begin_src python
(x := (y := (z := 5)))
#+end_src

Пример использования приведен в следующем разделе, а также можно обратиться к далеко не всегда хорошим паттернам использования этого свойства при разаработке на C.

*** Неявное приведение к логическому типу (*)

В python значения, не являющиеся значениями типа ~bool~, неявно приводятся к логическому типу, если их пытаться использовать в местах, где он требуется (например как операнды для логических операторов). Правила приведения следующие:
- ~0~, ~0.0~, ~0j~, ~Νone~, пустые списки ( ~[]~ ), кортежи ( ~()~ ), словари ( ~{}~ ), строки ( ~""~ ) и последовательности ( ~range(0)~ ) неявно приводятся к ~False~. Такие значения называются ~falsy~
- Все остальное (ненулевые числа, непустые строки и коллекции) неявно приводится к ~True~. Такие значения называются ~truthy~

Пример использования, например, такой:
#+begin_src python
  # do_something() - функция, принимающая на вход подключение к базе данных
  # conn - подключение к базе данных, которое при разрыве становится None
  # reconnect() - функция, возвращающая восстановленное подключение к базе данных

  do_something(conn or (conn := reconect()))
#+end_src

** Строки

Отнесение типа ~string~ к примитивным некорректно, как и в принципе термин "примитивный" тип по отношению к python, ведь все равно даже в числовых и логических типах мы работаем с упакованными в объекты сущностями. Но и относить его к коллекциям (что было бы правильно, ибо за кадром мы все равно имеем массив UTF-8 симоволов, а, на самом деле, для оптимизации там существенно более сложная конструкция с глобальным словарем, хранящим ровно одну копию эквивалентной строки. Подробнее, например, [[https://rushter.com/blog/python-strings-and-memory/][здесь]]) мне совсем не хочется, так как строка не особо воспринимается как коллекция (на высоком уровне, а не уровне реализации).

Строки могут быть как в одинарных, так и в двойных ковычка. Различий, как в каком-нибудь php, где интерполяция происходит только внутри двойных ковычек, тут нет, как нет и символьного типа. Интерполяция (возможность внутри строки писать в фигурных ковычках любые валидные выражения, которые будут вычислены) осуществляется с помощью префикса ~f~ перед открывающей ковычкой.
#+begin_src python :tangle "python/intro.py"
  some_string = "Καλημέρα ντουνιά!"
  another_string = 'Привет, мир!'

  x = 5
  interpolated_string = f"x is {x} and x^2 is {x ** 2}"
  print(interpolated_string)  # => x is 5 and x^2 is 25
#+end_src

Ответ на вопрос, какие ковычки использовать, звучит так: любые, главное везде одинаковые в рамках хотя бы одного репозитория. С настороженностью советовал бы относиться к советам использовать, например, одинарные ковычки, если в строке встречаются двойные. Тут достаточно вспомнить про ~\'~ и ~\"~, а не городить огород из разных ковычек:
#+begin_src python :tangle "python/intro.py"
  print("I can use double quotes inside \"that way\"")
  print('And \'single quotes\' also')
#+end_src

Для строк доступно большое количество методов, вот некоторые из них:
#+begin_src python :tangle "python/intro.py"
  s = "  some strInG  "
  print(s.strip())               # => "some strInG"
  print(s.strip().upper())       # => "SOME STRING"

  s = "ANOTHER STRING"
  print(s.lower())               # => "another string"
  print(s.replace("ING", "ONG")) # => "ANOTHER STRONG"
  print(s.split(" "))            # => ["ANOTHER", "STRING"]
#+end_src

Можем обратить внимание, что вызов методов не меняет исходную строку, а возвращает результат как новую, что позволяет выстраивать "цепочки" вызовов методов, как в ~s.strip().upper()~. В самом деле, строки в python, как в большинстве языков иммутабельны (неизменяемы).

** Управляющие конструкции
*** Ветвление

Конструкция ветвления ~if~ в python выглядит стандартно, но вокруг условия круглые скобки не требуются
#+begin_src python :tangle "python/intro.py"
  mark = 6.3

  if mark < 4:
      print("неудовлетворительно")
  elif mark < 6:
      print("удовлетворительно")
  elif mark < 8:
      print("хорошо")
  else:
      print("отлично")
#+end_src

Обращаю внимание, что ~if~ в примере сверху это /statement/, а не /expression/, то есть не возвращает никакого значения, чего иногда хотелось бы. Но ~if~ как выражение в языке тоже присутствует. Ниже пример, как его использовать для защиты от деления на ноль: 
#+begin_src python :tangle "python/intro.py"
  n_groups = 3
  total_amount = 9000

  amount_per_group = total_amount / n_groups if n_groups > 0 else total_amount
#+end_src

Конструкция ~switch~, присутствующая в подовляющем большинстве C-подобных языков, здесь отсутствует, но (начиная с версии 3.10) доступен оператор ~match~, который не только покрывает весь функционал ~switch~, но и позволяет производить структурный pattern matching. Для интересующихся немного об этом в соотвествующем подразделе со звездочкой, а ниже пример использования в роли ~switch~:
#+begin_src python :tangle "python/intro.py"
  read_input = "q"

  match read_input:
      case "q" | "quit":
          print("quiting...")
      case "r" | "run":
          print("running...")
      case cmd:
          print(f"you entered: {cmd}")
#+end_src

*** Циклы

В python нам доступны два вида циклов: ~while~ и ~for...in~:
#+begin_src python :tangle "python/intro.py"
  x = 10

  while x > 0:
      print(f"cube of {x} is {x ** 3}")
      x -= 1

  some_strings = ["foo", "bar", "baz"]
  for s in some_strings:
      print(s)
#+end_src

Сказать особо про них нечего, кроме того, что C-подобного синтаксиса для ~for~ (например, ~for int i = 0; i < len(some_strings); i++ {...}~) нет. Один важный момент только, что при обходе списка циклом ~for...in~ мы обходим по копии и, если нужно менять элементы списка, то делается это с помощью индекса:
#+begin_src python :tangle "python/intro.py"
  xs = [0, -2, 3, 4, -1, 6, -12, -2, 5]

  # напишем цикл, зануляющий отрицательные числа
  for elem, idx in enumerate(xs):
      if elem < 0:
          xs[idx] = 0
#+end_src

Если нужно пропустить итерацию, то используем инструкцию ~continue~. Если выйти из цикла заранее, то ~break~:
#+begin_src python :tangle "python/intro.py"
  for num in range(100):
      if num > 12:
          print("We are not interested in numbers greater than 12")
          break
      
      if num % 2 == 0:
          print(f"Found an even number {num}")
          continue

      print(f"Found an odd number {num}")
#+end_src

*** Structural pattern matching (*)

По-русски существует термин /сопоставление с образцом/, но вживую я его не слышал ни разу, поэтому будем использовать только английский вариант. В python пришло это из функциональных языков программирования. Мэтчить можно списки,  реализуем функцию ~map~ (которая применяет переданную функцию к каждому элементу списка и возвращает новый список):
#+begin_src python
  def my_map(func, xs):
      match xs:
          case []:
              return []
          case [x, *xs]:
              return [func(x)] + my_map(func, xs)

  print(my_map(lambda x: x ** 2, [0, 1, 2, 3, 4, 5]))
#+end_src

Можно мэтчить словари (по их отдельным полям), например:
#+begin_src python
  student = {
      "programme": "Economics",
      "grade": "B",
      "name": "Ivan Petrov"
  }

  match student:
      case {"grade": "A", "name": name}:
          print(f"Student {name} passed exam")
      case {"grade": "B" | "C", "programme": "Economics", "name": name}:
          print(f"Student {name} passed exam (B and C allowed for Economics)")
      case {"name": name}:
          print(f"Student {name} did not pass exam")
#+end_src

Обращаю внимание, что не требуется, чтобы ветви покрывали все возможные случаи (как в обоих случая выше), так как ~match~ это /statement/ и ничего не возвращает, что является существенным отличием от паттерн мэтчинга в функциональных языках. Если нужно обработать случай "все прочее", и не важно что именно прочее, используем конструкцию ~case _:~. Например:
#+begin_src python
  response = {
      "status": 200,
      "body": "Hello, World"
  }

  match response:
      case {"status": 200, "body": body}:
          print(f"Got response: {body}")
      case _:
          print("Request failed")
#+end_src

И кортежи тоже можно (заодно это пример, где ветви не покрывают все возможные случаи):
#+begin_src python
  def connect_to_database():
      # do some work
      return ("ok", connection)

  active_connection = None
  match connect_to_database():
      case ("ok", conn):
          active_connection = conn
#+end_src

Более подробно можно прочесть в [[https://peps.python.org/pep-0636/][PEP-636]].

** Функции

Функции задаются с помощью ключевого слова ~def~, если функция возвращает значение, то делаем это явно с помощью ~return~ (функция может и не возвращать ничего, к слову). Пример:
#+begin_src python :tangle "python/intro.py"
  def abs(x):
      return x if x >= 0 else -x
#+end_src

В самом начале вспоминали про /type hints/, выглядит следующим образом:
#+begin_src python :tangle "python/intro.py"
  def abs(x: int) -> int:
      return x if x >= 0 else -x

  # модуль может быть как от целого, так и с плавающей точкой
  # поэтому правильнее будет так
  def abs(x: int | float) -> int | float:
      return x if x >= 0 else -x
#+end_src

Но повторюсь, это про удобство и документацию функций, которые мы определяем, а не защита от ошибки на уровни системы типов. Код, где мы вызываем ~abs("12")~ будет выполнен до этой строчки при запуске.

В python функции являются /first-class citizens/. Формально строгого определения, как и перевода на русский, для этого определения не существует, но имеется в виду, что функции можно передавать как аргумент в другую функцию, возвращать из функции и присвоить переменной. Функции, принимающие как аргумент другие функции, называют функциями старшего порядка. Также присутствует и синтаксис для анонимных функций, которые могут быть полезны именно как аргумент:
#+begin_src python :tangle "python/intro.py"
  from functools import reduce

  square_function = lambda x: x ** 3

  sum_of_squares = reduce(
      lambda acc, el: acc + el,         # суммируем накопленное и элемент
      map(lambda x: x ** 2, range(11)), # возводим в квадрат числа от 0 до 10
      0                                 # начальное значение накопленного
  )
  # более идиоматический для python способ найти сумму квадратов
  # sum_of_squares = sum([x ** 2 for x in range(11)])

  print(f"sum of squares from 1 to 10 is {sum_of_squares}")
#+end_src

** Коллекции
*** Списки

*** Кортежи

*** Множества и словари

* Вариационное исчисление

* Оптимальное управление
